[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"Processing"})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/max/PPC/Projet_code/Projet_code/src/main/scala/CheckerActor.scala","languageId":"scala","version":1,"text":"package upmc.akka.leader\n\nimport java.util\nimport java.util.Date\n\nimport akka.actor._\n\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nabstract class Tick\ncase class CheckerTick () extends Tick\n\nclass CheckerActor (val id:Int, val terminaux:List[Terminal], electionActor:ActorRef) extends Actor {\n\n     var time : Int = 200\n     val father = context.parent\n\n     var nodesAlive:List[Int] = List()\n     var datesForChecking:List[Date] = List()\n     var lastDate:Date = null\n\n     var leader : Int = -1\n     \n\n    def receive = {\n\n         // Initialisation\n        case Start => {\n             self ! CheckerTick\n        }\n\n        // A chaque fois qu'on recoit un Beat : on met a jour la liste des nodes\n        case IsAlive (nodeId) => {\n         this.nodesAlive = this.nodesAlive:::List(nodeId)\n          \n         terminaux.foreach(n => {\n\n               //On rÃ©cupÃ¨re les acteurs Ã  partir de leur id et de leur port\n               val remote = context.actorSelection(\"akka.tcp://LeaderSystem\" + n.id + \"@\" + n.ip + \":\" + n.port + \"/user/Node\")\n               // Mise a jour de la liste des nodes\n               //remote ! Sync(nodesAlive)\n\n\n               terminaux.foreach(n2 => {\n\n               //On rÃ©cupÃ¨re les acteurs Ã  partir de leur id et de leur port\n               val remote = context.actorSelection(\"akka.tcp://LeaderSystem\" + n2.id + \"@\" + n2.ip + \":\" + n2.port + \"/user/Node\")\n               println(\"Remote : \"+remote)\n               // Mise a jour de la liste des nodes\n               //remote ! Sync(nodesAlive)\n               remote ! IsAlive(n.id)\n                   \n               })\n               \n                   \n               })\n          }\n\n        case IsAliveLeader (nodeId) => {\n          terminaux.foreach(n => {\n                   \n               if(nodesAlive(nodeId) !=null)\n                    father ! Message (\"I am the leader\")\n               else\n                    println(\"Lancer l'Ã©lection ici\")\n          })\n        }\n\n        // A chaque fois qu'on recoit un CheckerTick : on verifie qui est mort ou pas\n        // Objectif : lancer l'election si le leader est mort\n        case CheckerTick => {\n             //Il faut checker qui est mort en plus du leader\n            \n             terminaux.foreach(n => {\n               val remote = context.actorSelection(\"akka.tcp://LeaderSystem\" + n.id + \"@\" + n.ip + \":\" + n.port + \"/user/Node\")\n               remote ! IsAlive(n.id)\n               //check leader aussi\n          })\n            \n\n        }\n\n    }\n\n\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (/home/max/PPC/Projet_code/Projet_code/target/scala-2.11/zinc/inc_compile_2.11.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed 23 janv. 2021 12:32:06[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"Done"})[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled request received: shutdown: JsonRpcRequestMessage(2.0, â™¨1, shutdown, null})[0m
