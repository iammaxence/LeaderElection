[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"Processing"})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/max/PPC/Projet_code/Projet_code/src/main/scala/CheckerActor.scala","languageId":"scala","version":1,"text":"package upmc.akka.leader\n\nimport java.util\nimport java.util.Date\n\nimport akka.actor._\n\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nabstract class Tick\ncase class CheckerTick () extends Tick\n\nclass CheckerActor (val id:Int, val terminaux:List[Terminal], electionActor:ActorRef) extends Actor {\n\n     var time : Int = 200\n     val father = context.parent\n\n     var nodesAlive:List[Int] = List()\n     var datesForChecking:List[Date] = List()\n     var lastDate:Date = null\n\n     var leader : Int = -1\n\n    def receive = {\n\n         // Initialisation\n        case Start => {\n             self ! CheckerTick\n        }\n\n        // A chaque fois qu'on recoit un Beat : on met a jour la liste des nodes\n        case IsAlive (nodeId) => {\n         this.nodesAlive = this.nodesAlive:::List(nodeId)\n\n         terminaux.foreach(n => {\n               if (n.id != id) {\n                    val remote = context.actorSelection(\"akka.tcp://LeaderSystem\" + n.id + \"@\" + n.ip + \":\" + n.port + \"/user/Node\")\n                    // Mise a jour de la liste des nodes\n                     remote ! Sync(nodesAlive)\n               }\n                   \n               })\n          }\n\n        case IsAliveLeader (nodeId) => \n\n        // A chaque fois qu'on recoit un CheckerTick : on verifie qui est mort ou pas\n        // Objectif : lancer l'election si le leader est mort\n        case CheckerTick => \n\n    }\n\n\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (/home/max/PPC/Projet_code/Projet_code/target/scala-2.11/zinc/inc_compile_2.11.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed 16 janv. 2021 08:22:03[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"Done"})[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/max/PPC/Projet_code/Projet_code/src/main/scala/Node.scala","languageId":"scala","version":1,"text":"package upmc.akka.leader\n\nimport akka.actor._\n\ncase class Start ()\n\nsealed trait SyncMessage\ncase class Sync (nodes:List[Int]) extends SyncMessage\ncase class SyncForOneNode (nodeId:Int, nodes:List[Int]) extends SyncMessage\n\nsealed trait AliveMessage\ncase class IsAlive (id:Int) extends AliveMessage\ncase class IsAliveLeader (id:Int) extends AliveMessage\n\nclass Node (val id:Int, val terminaux:List[Terminal]) extends Actor {\n     \n     // Les differents acteurs du systeme\n     val electionActor = context.actorOf(Props(new ElectionActor(this.id, terminaux)), name = \"electionActor\")\n     val checkerActor = context.actorOf(Props(new CheckerActor(this.id, terminaux, electionActor)), name = \"checkerActor\")\n     val beatActor = context.actorOf(Props(new BeatActor(this.id)), name = \"beatActor\")\n     val displayActor = context.actorOf(Props[DisplayActor], name = \"displayActor\")\n\n     var allNodes:List[ActorSelection] = List()\n     var nodesAlive:List[Int] = List()\n     def receive = {\n\n          // Initialisation\n          case Start => {\n               displayActor ! Message (\"Node \" + this.id + \" is created\")\n               checkerActor ! Start\n               beatActor ! Start\n\n\n               // Initilisation des autres remote, pour communiquer avec eux\n               terminaux.foreach(n => {\n                    if (n.id != id) {\n                         val remote = context.actorSelection(\"akka.tcp://LeaderSystem\" + n.id + \"@\" + n.ip + \":\" + n.port + \"/user/Node\")\n                         // Mise a jour de la liste des nodes\n                         this.allNodes = this.allNodes:::List(remote)\n                    }\n                   \n               })\n\n               //  this.nodesAlive = this.nodesAlive:::List(this.id)\n               //  allNodes.foreach(n => n ! Sync(this.nodesAlive) )\n          }\n\n          case Sync (listNode) => {\n               this.nodesAlive = this.nodesAlive:::listNode\n               println(\"Nodes Alives : \"+ this.nodesAlive)\n          }\n\n          // Envoi de messages (format texte)\n          case Message (content) => {\n               displayActor ! Message (content)\n          }\n\n          case BeatLeader (nodeId) => \n\n          case Beat (nodeId) => checkerActor ! IsAlive (nodeId)\n\n          // Messages venant des autres nodes : pour nous dire qui est encore en vie ou mort\n          case IsAlive (id) => \n\n          case IsAliveLeader (id) => \n\n          // Message indiquant que le leader a change\n          case LeaderChanged (nodeId) => \n\n     }\n\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mForcing garbage collection...[0m
